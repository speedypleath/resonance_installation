<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Biometric Monitor Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1e3c72 0%,
          #2a5298 50%,
          #667eea 100%
        );
        color: white;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .header {
        background: rgba(255, 255, 255, 0.1);
        padding: 25px;
        backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        text-align: center;
        font-size: 3rem;
        margin-bottom: 15px;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        background: linear-gradient(45deg, #ffd700, #ffa500);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .status-bar {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        backdrop-filter: blur(5px);
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        animation: pulse 2s infinite;
      }

      .status-connected {
        background-color: #4caf50;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
      }
      .status-disconnected {
        background-color: #f44336;
        box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
      }
      .status-processing {
        background-color: #ff9800;
        box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.7;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .controls {
        text-align: center;
        margin-top: 20px;
      }

      .btn {
        background: linear-gradient(
          45deg,
          rgba(255, 255, 255, 0.2),
          rgba(255, 255, 255, 0.1)
        );
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 12px 24px;
        margin: 5px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1rem;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        font-weight: 500;
      }

      .btn:hover {
        background: linear-gradient(
          45deg,
          rgba(255, 255, 255, 0.3),
          rgba(255, 255, 255, 0.2)
        );
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-primary {
        background: linear-gradient(45deg, #4caf50, #45a049);
      }

      .btn-danger {
        background: linear-gradient(45deg, #f44336, #da190b);
      }

      .btn-warning {
        background: linear-gradient(45deg, #ff9800, #f57c00);
      }

      .main-content {
        padding: 20px;
        display: grid;
        gap: 20px;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.1);
        padding: 25px;
        border-radius: 20px;
        text-align: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .stat-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #ffd700, #ffa500, #ff6b35);
      }

      .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .stat-card h3 {
        font-size: 2.5rem;
        margin-bottom: 8px;
        color: #ffd700;
        font-weight: 700;
      }

      .stat-card p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .pipeline-section {
        background: rgba(255, 255, 255, 0.08);
        padding: 25px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        margin-bottom: 25px;
      }

      .pipeline-section h2 {
        color: #ffd700;
        margin-bottom: 20px;
        font-size: 1.8rem;
        text-align: center;
      }

      .pipeline-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .data-visualization {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
        margin-top: 20px;
      }

      .eeg-visualization {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .plot-container {
        background: rgba(255, 255, 255, 0.08);
        padding: 20px;
        border-radius: 15px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 400px;
      }

      .eeg-plot-container {
        background: rgba(255, 255, 255, 0.08);
        padding: 15px;
        border-radius: 12px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 280px;
        display: grid;
      }

      .plot-container h3 {
        margin-bottom: 15px;
        text-align: center;
        color: #ffd700;
        font-size: 1.4rem;
      }

      .eeg-plot-container h4 {
        margin-bottom: 10px;
        text-align: center;
        color: #ffd700;
        font-size: 1.1rem;
      }

      .emotion-display {
        text-align: center;
        padding: 30px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .current-emotion {
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 10px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .confidence-bar {
        width: 100%;
        height: 20px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        margin: 15px 0;
      }

      .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #8bc34a);
        border-radius: 10px;
        transition: width 0.3s ease;
      }

      .vad-display {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 15px;
        margin-top: 20px;
      }

      .vad-item {
        text-align: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }

      .vad-value {
        font-size: 1.8rem;
        font-weight: bold;
        color: #ffd700;
      }

      .log-container {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px;
        font-family: "Courier New", monospace;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .log-entry {
        margin: 8px 0;
        padding: 8px 12px;
        border-left: 3px solid #ffd700;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
      }

      .log-timestamp {
        color: #ffd700;
        font-weight: bold;
      }

      .full-width {
        grid-column: 1 / -1;
      }

      .camera-container {
        position: relative;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .camera-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        justify-content: space-between;
        pointer-events: none;
      }

      .camera-status,
      .fps-counter {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.8rem;
        backdrop-filter: blur(5px);
      }

      .camera-controls {
        text-align: center;
        margin-top: 10px;
      }

      .camera-controls button {
        padding: 8px 16px;
        font-size: 0.8rem;
        margin: 0 5px;
      }

      #cameraFeed {
        display: block;
        max-width: 100%;
        height: auto;
        border-radius: 10px;
      }

      .camera-error {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 300px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        color: rgba(255, 255, 255, 0.7);
        text-align: center;
      }

      .eeg-section {
        background: rgba(255, 255, 255, 0.08);
        padding: 25px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        margin-bottom: 25px;
      }

      .eeg-section h2 {
        color: #ffd700;
        margin-bottom: 20px;
        font-size: 1.8rem;
        text-align: center;
      }

      @media (max-width: 768px) {
        .data-visualization {
          grid-template-columns: 1fr;
        }

        .eeg-visualization {
          grid-template-columns: 1fr;
        }

        .stats-grid {
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .header h1 {
          font-size: 2rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Biometric Monitor Dashboard</h1>
      <div class="status-bar">
        <div class="status-indicator">
          <div
            id="connectionStatus"
            class="status-dot status-disconnected"
          ></div>
          <span id="connectionText">Connecting...</span>
        </div>
        <div class="status-indicator">
          <div id="emotionStatus" class="status-dot status-disconnected"></div>
          <span>Facial Emotion Recognition</span>
        </div>
        <div class="status-indicator">
          <div id="eegStatus" class="status-dot status-disconnected"></div>
          <span>EEG Monitoring</span>
        </div>
        <div class="status-indicator">
          <div id="gsrStatus" class="status-dot status-disconnected"></div>
        <span>GSR Monitoring</span>
        </div>
      </div>
      <div class="controls">
        <button class="btn btn-primary" onclick="startAllPipelines()">
          Start All
        </button>
        <button class="btn btn-danger" onclick="stopAllPipelines()">
          Stop All
        </button>
        <button class="btn btn-warning" onclick="pauseAllPipelines()">
          Pause All
        </button>
        <button class="btn btn-primary" onclick="resumeAllPipelines()">
          Resume All
        </button>
        <button class="btn" onclick="testOSC()">Test OSC</button>
        <button class="btn" onclick="clearLogs()">Clear Logs</button>
      </div>
    </div>

    <div class="main-content">
      <!-- Statistics Grid -->
      <div class="stats-grid">
        <div class="stat-card">
          <h3 id="emotionCount">0</h3>
          <p>Emotions Detected</p>
        </div>
        <div class="stat-card">
          <h3 id="eegFragments">0</h3>
          <p>EEG Fragments</p>
        </div>
        <div class="stat-card">
          <h3 id="oscMessages">0</h3>
          <p>OSC Messages</p>
        </div>
        <div class="stat-card">
          <h3 id="uptime">0s</h3>
          <p>System Uptime</p>
        </div>
      </div>

      <!-- Pipeline Controls -->
      <div class="pipeline-section">
        <h2>Individual Pipeline Controls</h2>
        <div class="pipeline-controls">
          <button
            class="btn btn-primary"
            onclick="startPipeline('facial_emotion')"
          >
            Start Emotion
          </button>
          <button
            class="btn btn-danger"
            onclick="stopPipeline('facial_emotion')"
          >
            Stop Emotion
          </button>
          <button
            class="btn btn-primary"
            onclick="startPipeline('eeg_processing')"
          >
            Start EEG
          </button>
          <button
            class="btn btn-danger"
            onclick="stopPipeline('eeg_processing')"
          >
            Stop EEG
          </button>
        </div>
      </div>

      <!-- Data Visualization -->
      <div class="data-visualization">
        <!-- Live Camera Feed -->
        <div class="plot-container">
          <h3>Live Camera Feed</h3>
          <div class="camera-container">
            <img
              id="cameraFeed"
              src="/video_feed"
              alt="Camera feed not available"
              style="
                width: 100%;
                height: auto;
                border-radius: 10px;
                background: rgba(255, 255, 255, 0.1);
              "
            />
            <div class="camera-overlay">
              <div class="camera-status" id="cameraStatus">
                Camera: Disconnected
              </div>
              <div class="fps-counter" id="fpsCounter">FPS: 0</div>
            </div>
          </div>
        </div>
        <!-- Emotion Probability Chart -->

        <div class="plot-container">
          <h3>Emotion Probabilities</h3>
          <div id="emotionProbPlot"></div>
        </div>

        <!-- Emotion Recognition Display -->
        <div class="plot-container full-width">
          <h3>Real-Time Emotion Recognition</h3>
          <div class="emotion-display">
            <div class="current-emotion" id="currentEmotion">Neutral</div>
            <div class="confidence-bar">
              <div
                class="confidence-fill"
                id="confidenceBar"
                style="width: 0%"
              ></div>
            </div>
            <div>Confidence: <span id="confidenceText">0%</span></div>

            <div class="vad-display">
              <div class="vad-item">
                <div>Valence</div>
                <div class="vad-value" id="valenceValue">0.000</div>
              </div>
              <div class="vad-item">
                <div>Arousal</div>
                <div class="vad-value" id="arousalValue">0.000</div>
              </div>
              <div class="vad-item">
                <div>Dominance</div>
                <div class="vad-value" id="dominanceValue">0.000</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- EEG Individual Channel Monitoring -->
      <div class="eeg-section">
        <h2>EEG Channel Monitoring</h2>
        <div class="eeg-visualization">
          <!-- TP9 Channel -->
          <div class="eeg-plot-container">
            <h4>TP9 Channel</h4>
            <div id="eegPlotTP9"></div>
          </div>

          <!-- AF7 Channel -->
          <div class="eeg-plot-container">
            <h4>AF7 Channel</h4>
            <div id="eegPlotAF7"></div>
          </div>

          <!-- AF8 Channel -->
          <div class="eeg-plot-container">
            <h4>AF8 Channel</h4>
            <div id="eegPlotAF8"></div>
          </div>

          <!-- TP10 Channel -->
          <div class="eeg-plot-container">
            <h4>TP10 Channel</h4>
            <div id="eegPlotTP10"></div>
          </div>
        </div>
      </div>

      <!-- Activity Log -->
      <div class="pipeline-section">
        <h2>Activity Log</h2>
        <div class="log-container" id="logContainer">
          <div class="log-entry">
            <span class="log-timestamp">[System]</span> Dashboard loaded - Ready
            to connect
          </div>
        </div>
      </div>
    </div>

    <script>
      // WebSocket connection
      const socket = io();
      const channelNames = ["TP9", "AF7", "AF8", "TP10"];

      // Global state
      let emotionCount = 0;
      let eegFragmentCount = 0;
      let oscMessageCount = 0;
      let systemStartTime = Date.now();
      let cameraFpsCounter = 0;
      let lastCameraUpdate = Date.now();

      // Camera feed management
      function initializeCameraFeed() {
        const cameraFeed = document.getElementById("cameraFeed");
        const cameraStatus = document.getElementById("cameraStatus");

        cameraFeed.onload = function () {
          cameraStatus.textContent = "Camera: Connected";
          updateCameraFPS();
        };

        cameraFeed.onerror = function () {
          cameraStatus.textContent = "Camera: Error";
          cameraFeed.style.display = "none";
          showCameraError();
        };

        // Refresh camera feed periodically to handle connection issues
        setInterval(refreshCameraFeed, 5000);
      }

      function refreshCameraFeed() {
        const cameraFeed = document.getElementById("cameraFeed");
        if (cameraFeed.src) {
          // Add timestamp to bypass cache
          cameraStatus.textContent = "Camera: Refreshing...";
          const baseUrl = "/video_feed";
          const timestamp = new Date().getTime();
          cameraFeed.src = `${baseUrl}?t=${timestamp}`;
        }
      }

      function updateCameraFPS() {
        cameraFpsCounter++;
        const now = Date.now();
        const elapsed = (now - lastCameraUpdate) / 1000;

        if (elapsed >= 1.0) {
          const fps = cameraFpsCounter / elapsed;
          document.getElementById(
            "fpsCounter"
          ).textContent = `FPS: ${fps.toFixed(1)}`;
          cameraFpsCounter = 0;
          lastCameraUpdate = now;
        }
      }

      function showCameraError() {
        const cameraFeed = document.getElementById("cameraFeed");
        cameraFeed.style.display = "none";

        const container = cameraFeed.parentElement;
        if (!container.querySelector(".camera-error")) {
          const errorDiv = document.createElement("div");
          errorDiv.className = "camera-error";
          errorDiv.innerHTML = `
                    <div>
                        <div style="font-size: 2rem; margin-bottom: 10px;">ðŸ“·</div>
                        <div>Camera not available</div>
                        <div style="font-size: 0.8rem; margin-top: 10px; opacity: 0.7;">
                            Start emotion recognition to enable camera feed
                        </div>
                    </div>
                `;
          container.appendChild(errorDiv);
        }
      }

      function hideCameraError() {
        const cameraFeed = document.getElementById("cameraFeed");
        const container = cameraFeed.parentElement;
        const errorDiv = container.querySelector(".camera-error");

        if (errorDiv) {
          errorDiv.remove();
        }

        cameraFeed.style.display = "block";
      }

      // Connection handling
      socket.on("connect", function () {
        document.getElementById("connectionStatus").className =
          "status-dot status-connected";
        document.getElementById("connectionText").textContent = "Connected";
        addLog("Connected to server");
        requestStats();
      });

      socket.on("disconnect", function () {
        document.getElementById("connectionStatus").className =
          "status-dot status-disconnected";
        document.getElementById("connectionText").textContent = "Disconnected";
        addLog("Disconnected from server");
      });

      // Pipeline control functions
      function startPipeline(pipelineName) {
        socket.emit("request_pipeline_control", {
          action: "start",
          pipeline: pipelineName,
        });
      }

      function stopPipeline(pipelineName) {
        socket.emit("request_pipeline_control", {
          action: "stop",
          pipeline: pipelineName,
        });
      }

      function startAllPipelines() {
        startPipeline("facial_emotion");
        startPipeline("gsr_stress_detection");
        startPipeline("eeg_processing");
      }

      function stopAllPipelines() {
        stopPipeline("facial_emotion");
        stopPipeline("gsr_stress_detection");
        stopPipeline("eeg_processing");
      }

      function pauseAllPipelines() {
        socket.emit("request_pipeline_control", {
          action: "pause",
          pipeline: "all",
        });
      }

      function resumeAllPipelines() {
        socket.emit("request_pipeline_control", {
          action: "resume",
          pipeline: "all",
        });
      }

      function testOSC() {
        fetch("/api/osc/test", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ client: "default" }),
        })
          .then((response) => response.json())
          .then((data) => {
            addLog(`OSC test: ${data.success ? "Success" : "Failed"}`);
          })
          .catch((error) => {
            addLog(`OSC test error: ${error}`);
          });
      }

      function requestStats() {
        socket.emit("request_stats");
      }

      // Data handlers
      socket.on("emotion_update", function (data) {
        updateEmotionDisplay(data);
        emotionCount++;
        updateStats();
      });

      socket.on("eeg_update", function (data) {
        updateEEGDisplay(data);
        eegFragmentCount += data.fragments ? data.fragments.length : 0;
        updateStats();
      });

      socket.on("pipeline_control_response", function (data) {
        addLog(data.message);
        updatePipelineStatus(data.pipeline, data.action, data.success);
      });

      socket.on("stats_update", function (data) {
        updateSystemStats(data);
      });

      // Update functions
      function updateEmotionDisplay(data) {
        document.getElementById("currentEmotion").textContent = data.emotion;
        document.getElementById("confidenceText").textContent = `${(
          data.confidence * 100
        ).toFixed(1)}%`;
        document.getElementById("confidenceBar").style.width = `${
          data.confidence * 100
        }%`;

        if (data.vad) {
          document.getElementById("valenceValue").textContent =
            data.vad.valence.toFixed(3);
          document.getElementById("arousalValue").textContent =
            data.vad.arousal.toFixed(3);
          document.getElementById("dominanceValue").textContent =
            data.vad.dominance.toFixed(3);
        }

        // Update emotion probabilities chart
        if (data.probabilities) {
          updateEmotionProbChart(data.probabilities);
        }

        addLog(
          `Emotion: ${data.emotion} (${(data.confidence * 100).toFixed(1)}%)`
        );
      }

      function updateEEGDisplay(data) {
        if (data.fragments && data.fragments.length > 0) {
          const fragment = data.fragments[0];
          updateEEGChannelPlots(fragment);
          addLog(`EEG Fragment ${fragment.fragment_id} processed`);
        }
      }

      function updateEEGChannelPlots(fragment) {
        const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"];

        for (
          let ch = 0;
          ch < channelNames.length && ch < fragment.data[0].length;
          ch++
        ) {
          const channelData = fragment.data.map((sample) => sample[ch]);
          const timeAxis = fragment.timestamps
            ? fragment.timestamps.map((ts, idx) => idx / 256)
            : fragment.data.map((_, idx) => idx / 256);

          const trace = {
            x: timeAxis,
            y: channelData,
            type: "scatter",
            mode: "lines",
            line: {
              width: 2,
              color: colors[ch],
            },
            showlegend: false,
          };

          const layout = {
            xaxis: {
              title: "Time (s)",
              color: "white",
              gridcolor: "rgba(255,255,255,0.1)",
              showline: true,
              linecolor: "rgba(255,255,255,0.3)",
            },
            yaxis: {
              title: "Î¼V",
              color: "white",
              gridcolor: "rgba(255,255,255,0.1)",
              showline: true,
              linecolor: "rgba(255,255,255,0.3)",
            },
            paper_bgcolor: "rgba(0,0,0,0)",
            plot_bgcolor: "rgba(255,255,255,0.05)",
            font: { color: "white", size: 10 },
            margin: { t: 20, b: 40, l: 50, r: 20 },
          };

          const plotId = `eegPlot${channelNames[ch]}`;
          Plotly.react(plotId, [trace], layout, { responsive: true });
        }
      }

      function updateEmotionProbChart(probabilities) {
        const emotions = Object.keys(probabilities);
        const values = Object.values(probabilities);
        const maxIndex = values.indexOf(Math.max(...values));

        const trace = {
          x: emotions,
          y: values,
          type: "bar",
          marker: {
            color: values.map((val, idx) =>
              idx === maxIndex ? "#FFD700" : "#4CAF50"
            ),
            line: {
              color: "rgba(255,255,255,0.2)",
              width: 1,
            },
          },
        };

        const layout = {
          title: {
            text: "Current Emotion Probabilities",
            font: { color: "white" },
          },
          xaxis: {
            color: "white",
            gridcolor: "rgba(255,255,255,0.1)",
          },
          yaxis: {
            title: "Probability",
            color: "white",
            gridcolor: "rgba(255,255,255,0.1)",
            range: [0, 1],
          },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(255,255,255,0.05)",
          font: { color: "white" },
          margin: { t: 50, b: 60, l: 60, r: 20 },
        };

        Plotly.react("emotionProbPlot", [trace], layout);
      }

      function updateStats() {
        document.getElementById("emotionCount").textContent = emotionCount;
        document.getElementById("eegFragments").textContent = eegFragmentCount;
        document.getElementById("oscMessages").textContent = oscMessageCount;

        const uptime = Math.floor((Date.now() - systemStartTime) / 1000);
        document.getElementById("uptime").textContent = formatUptime(uptime);
      }

      function formatUptime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
          return `${minutes}m ${secs}s`;
        } else {
          return `${secs}s`;
        }
      }

      function updatePipelineStatus(pipeline, action, success) {
        let statusElement;

        if (pipeline === "facial_emotion") {
          statusElement = document.getElementById("emotionStatus");
        } else if (pipeline === "eeg_processing") {
          statusElement = document.getElementById("eegStatus");
        }

        if (statusElement) {
          if (success) {
            statusElement.className = "status-dot status-connected";
          } else if (action === "start" && success) {
            statusElement.className = "status-dot status-processing";
          } else if (action === "stop") {
            statusElement.className = "status-dot status-disconnected";
          }
        }
      }

      function updateSystemStats(data) {
        if (data.server) {
          const uptime = Math.floor(data.server.uptime);
          document.getElementById("uptime").textContent = formatUptime(uptime);
        }

        if (data.osc && data.osc.clients) {
          let totalMessages = 0;
          Object.values(data.osc.clients).forEach((client) => {
            totalMessages += client.message_count || 0;
          });
          oscMessageCount = totalMessages;
          document.getElementById("oscMessages").textContent = totalMessages;
        }
      }

      // Logging
      function addLog(message) {
        const logContainer = document.getElementById("logContainer");
        const logEntry = document.createElement("div");
        logEntry.className = "log-entry";

        const timestamp = new Date().toLocaleTimeString();
        logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;

        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;

        // Keep only last 100 log entries
        while (logContainer.children.length > 100) {
          logContainer.removeChild(logContainer.firstChild);
        }
      }

      function clearLogs() {
        document.getElementById("logContainer").innerHTML = "";
        addLog("Logs cleared");
      }

      // Initialize dashboard
      window.addEventListener("load", function () {
        addLog("Dashboard initialized");

        initializeCameraFeed();
        startAllPipelines();
        // Initialize empty plots
        initializeEmptyPlots();

        // Request initial stats
        setTimeout(requestStats, 1000);

        // Set up periodic stats updates
        setInterval(requestStats, 5000);
        setInterval(updateStats, 1000);
      });

      function initializeEmptyPlots() {
        const emptyLayout = {
          title: { text: "Waiting for data...", font: { color: "white" } },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(255,255,255,0.05)",
          font: { color: "white" },
        };

        const emptyEEG = {
          xaxis: {
            title: "Time (s)",
            color: "white",
            gridcolor: "rgba(255,255,255,0.1)",
            showline: true,
            linecolor: "rgba(255,255,255,0.3)",
          },
          yaxis: {
            title: "Î¼V",
            color: "white",
            gridcolor: "rgba(255,255,255,0.1)",
            showline: true,
            linecolor: "rgba(255,255,255,0.3)",
          },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(255,255,255,0.05)",
          font: { color: "white", size: 10 },
          margin: { t: 20, b: 40, l: 50, r: 20 },
        };

        Plotly.newPlot("emotionProbPlot", [], emptyLayout);
        for (let ch = 0; ch < channelNames.length; ch++) {
          const plotId = `eegPlot${channelNames[ch]}`;
          Plotly.newPlot(plotId, [], emptyEEG);
        }
      }
    </script>
  </body>
</html>
